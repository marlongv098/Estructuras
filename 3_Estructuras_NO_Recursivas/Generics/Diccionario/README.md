ğŸ“¦  Diccionario

â”£ ğŸ“‚ src

â”ƒ â”£ ğŸ“‚ main

â”ƒ â”ƒ â”£ ğŸ“‚ java

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ diccionario

â”ƒ â”ƒ â”ƒ â”ƒ â”£   ğŸ“œ  Diccionario

â”ƒ â”ƒ â”ƒ â”ƒ â”£  ğŸ“œ  DiccionarioIntefaz

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ tablahash

â”ƒ â”ƒ â”ƒ â”ƒ â”£  ğŸ“œ TablaHash

â”ƒ â”ƒ â”ƒ â”ƒ â”£  ğŸ“œ  TablaHashInterfaz

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ ui

â”ƒ â”ƒ â”ƒ â”ƒ â”£  ğŸ“œ  Main

â”ƒ â”£ ğŸ“‚ test

â”ƒ â”ƒ â”£ ğŸ“‚  java 

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ diccionario

â”ƒ â”ƒ â”ƒ â”ƒ â”£   ğŸ“œ DiccionarioTest

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ tablahash

â”ƒ â”ƒ â”ƒ â”ƒ â”£   ğŸ“œ  TablaHashTest


## Diccionarios

### Â¿QuÃ© es una estructura de datos de tipo Diccionario?

- Es una estructura utilizada para manipular objetos en la que se insertan y extraen elementos periÃ³dicamente.
- Se puede verificar si un elemento especÃ­fico pertenece o no a la colecciÃ³n.

### Â¿CÃ³mo se conocen los diccionarios?

- **Arreglos asociativos** o **Mapas**.

### Â¿QuÃ© tiene cada elemento en un diccionario?

- Cada elemento tiene:
  - **Una clave (key)**.
  - **Un valor asociado (value)** a esa clave.

- La analogÃ­a con un diccionario del mundo real es que:
  - **Las palabras** representan las claves.
  - **Las definiciones** representan los valores asociados a esas claves.

### Â¿CÃ³mo almacena los datos un diccionario?

- A travÃ©s de pares:
- **(clave, valor)**.
- Los datos almacenados en la estructura son los **valores**.
- La **clave** se usa para buscar y encontrar los valores requeridos.

### Â¿En quÃ© ejemplos del mundo real se pueden usar diccionarios?

[Diccionario](https://github.com/marlongv098/Estructuras/blob/master/3_Estructuras_NO_Recursivas/Generics/Diccionario/src/main/java/diccionario/Diccionario.java)

### Â¿CuÃ¡l es la diferencia entre un array y un diccionario?

- En un **array**, la clave debe ser un nÃºmero (entero positivo o no negativo).
- En un **diccionario**, la clave puede ser cualquier tipo de objeto.

### Â¿QuÃ© suelen ser estas claves?

- Un conjunto de valores aleatorios como nÃºmeros reales o cadenas de texto.
- **Cada clave debe ser Ãºnica** dentro del diccionario.

### Â¿QuÃ© operaciones bÃ¡sicas define esta estructura de datos?

- $void Add(K key, V value)$ â†’ Agregar un par clave-valor.
- $V Get(K key)$ â†’ Obtener el valor asociado a una clave.
- $boolean Remove(K key)$ â†’ Eliminar un par clave-valor.

### Â¿QuÃ© mÃ©todos adicionales pueden existir?

- $boolean Contains(K key)$ â†’ Verificar si una clave estÃ¡ en el diccionario.
- $int Count()$ â†’ Obtener la cantidad de elementos almacenados.

---

### Â¿Por quÃ© es importante la implementaciÃ³n de operaciones en un diccionario?

- Muchas aplicaciones requieren un conjunto dinÃ¡mico que soporte Ãºnicamente las operaciones **INSERTAR, BUSCAR y ELIMINAR**.

### Â¿Algunos ejemplos?

- **Compiladores** (traductores de lenguajes de programaciÃ³n):
  - Mantienen una **tabla de sÃ­mbolos**.
  - En ella, las claves son **cadenas de caracteres arbitrarias** que corresponden a identificadores en el lenguaje.

### Â¿CuÃ¡l es una forma eficiente de implementar diccionarios?

- **Utilizando tablas hash**.

[Tabla Hash](https://github.com/marlongv098/Estructuras/blob/master/3_Estructuras_NO_Recursivas/Generics/Diccionario/src/main/java/tablahash/TablaHash.java)

### Â¿Por quÃ©?

- Aunque en el peor caso la bÃºsqueda en una tabla hash puede tardar **Î˜(n)**, en la prÃ¡ctica el rendimiento es muy bueno.
- Bajo suposiciones razonables, el **tiempo promedio de bÃºsqueda** en una tabla hash es **O(1)**.

### Â¿QuÃ© hace una tabla hash?

- Generaliza la nociÃ³n de un **array ordinario**.
- **Acceder directamente** a una posiciÃ³n en un array se hace en **O(1)**.
- Cuando se pueden asignar posiciones a todas las claves posibles, **los arrays son eficientes**.
- Si el nÃºmero de claves almacenadas es pequeÃ±o en comparaciÃ³n con el nÃºmero total de claves posibles, las **tablas hash son una alternativa efectiva**.

# Direccionamiento Directo

### Â¿QuÃ© es el direccionamiento directo?

- Es una tÃ©cnica sencilla que funciona bien cuando el universo $U$ de claves es relativamente pequeÃ±o.
- Supongamos que una aplicaciÃ³n necesita un conjunto dinÃ¡mico en el que cada elemento tiene una clave tomada del universo $U = {0,1,...,m-1}$, donde $m$ no es muy grande y no hay dos elementos con la misma clave.
	- Para representar el conjunto dinÃ¡mico, se usa un **array** o **tabla de direccionamiento directo**, denotado como $T[0..m-1]$.
	- Cada posiciÃ³n o **slot** en el array corresponde a una clave en el universo $U$.
	- El **slot $k$** apunta a un elemento del conjunto con clave $k$.
	- Si el conjunto no contiene un elemento con clave $k$, entonces $T[k] = NIL$.

### Â¿CÃ³mo serÃ­a la implementaciÃ³n de operaciones en un diccionario usando direccionamiento directo?

```java
// BÃºsqueda en direccionamiento directo
T[k] 

// InserciÃ³n en direccionamiento directo
T[x.key] = x 

// EliminaciÃ³n en direccionamiento directo
T[x.key] = NIL 
```

Cada una de estas operaciones tiene un tiempo de ejecuciÃ³n de $O(1)$.

### Ejemplo

Dado el universo $U={0,1,...,9}$ y el conjunto de claves $K={2,3,5,8}$:

[Directo](Images/hash.pdf)

### Â¿CuÃ¡l es la desventaja del direccionamiento directo?

* Si el universo $U$ es muy grande, almacenar una tabla $T$ de tamaÃ±o $|U|$ puede ser imprÃ¡ctico o incluso imposible debido a las limitaciones de memoria de un ordenador tÃ­pico.
* Si $|K|<<|U|$ la mayor parte del espacio reservado para $T$ serÃ­a desperdiciado.

### Â¿QuÃ© hacer si $|K|<<|U|$?

* Usar una tabla hash, ya que requiere mucho menos almacenamiento que una tabla de direccionamiento directo.
* Se puede reducir el requisito de almacenamiento a $Î˜(|K|)$.
* Se mantiene la ventaja de que la bÃºsqueda de un elemento en la tabla hash sigue requiriendo solo $O(1)$ en el caso promedio. Sin embargo, en el peor caso puede tomar mÃ¡s tiempo.

### Â¿QuÃ© es el hashing?

* Mientras que en el direccionamiento directo un elemento con clave $k$ se almacena en la posiciÃ³n $k$, con hashing se almacena en la posiciÃ³n $h(k)$. Se utiliza una funciÃ³n hash $h$ para calcular la posiciÃ³n a partir de la clave $k$.
* La funciÃ³n $h$ mapea el universo $U$ de claves en los slots de una tabla hash $T[0..mâˆ’1]$.

### RepresentaciÃ³n matemÃ¡tica

$$
h:Uâ†’{0,1,...,mâˆ’1}
$$

* Donde $m<<|U|$ y cada elemento tiene una clave distinta $h(k)$ es el valor hash de la clave $k$.
* La funciÃ³n hash reduce el rango de Ã­ndices del array y, por lo tanto, el tamaÃ±o del array.
* En lugar de tener un tamaÃ±o de $|U|$, la tabla puede tener un tamaÃ±o de $m$.

[HashMap](Images/hash1.pdf)








