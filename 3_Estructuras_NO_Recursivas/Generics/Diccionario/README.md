ğŸ“¦  Diccionario

â”£ ğŸ“‚ src

â”ƒ â”£ ğŸ“‚ main

â”ƒ â”ƒ â”£ ğŸ“‚ java

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ diccionario

â”ƒ â”ƒ â”ƒ â”ƒ â”£   ğŸ“œ  Diccionario

â”ƒ â”ƒ â”ƒ â”ƒ â”£  ğŸ“œ  DiccionarioIntefaz

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ tablahash

â”ƒ â”ƒ â”ƒ â”ƒ â”£  ğŸ“œ TablaHash

â”ƒ â”ƒ â”ƒ â”ƒ â”£  ğŸ“œ  TablaHashInterfaz

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ ui

â”ƒ â”ƒ â”ƒ â”ƒ â”£  ğŸ“œ  Main

â”ƒ â”£ ğŸ“‚ test

â”ƒ â”ƒ â”£ ğŸ“‚  java 

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ diccionario

â”ƒ â”ƒ â”ƒ â”ƒ â”£   ğŸ“œ DiccionarioTest

â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ tablahash

â”ƒ â”ƒ â”ƒ â”ƒ â”£   ğŸ“œ  TablaHashTest


## Diccionarios

### Â¿QuÃ© es una estructura de datos de tipo Diccionario?

- Es una estructura utilizada para manipular objetos en la que se insertan y extraen elementos periÃ³dicamente.
- Se puede verificar si un elemento especÃ­fico pertenece o no a la colecciÃ³n.

### Â¿CÃ³mo se conocen los diccionarios?

- **Arreglos asociativos** o **Mapas**.

### Â¿QuÃ© tiene cada elemento en un diccionario?

- Cada elemento tiene:
  - **Una clave (key)**.
  - **Un valor asociado (value)** a esa clave.

- La analogÃ­a con un diccionario del mundo real es que:
  - **Las palabras** representan las claves.
  - **Las definiciones** representan los valores asociados a esas claves.

### Â¿CÃ³mo almacena los datos un diccionario?

- A travÃ©s de pares:
- **(clave, valor)**.
- Los datos almacenados en la estructura son los **valores**.
- La **clave** se usa para buscar y encontrar los valores requeridos.

### Â¿En quÃ© ejemplos del mundo real se pueden usar diccionarios?

[Diccionario](https://github.com/marlongv098/Estructuras/blob/master/3_Estructuras_NO_Recursivas/Generics/Diccionario/src/main/java/diccionario/Diccionario.java)

### Â¿CuÃ¡l es la diferencia entre un array y un diccionario?

- En un **array**, la clave debe ser un nÃºmero (entero positivo o no negativo).
- En un **diccionario**, la clave puede ser cualquier tipo de objeto.

### Â¿QuÃ© suelen ser estas claves?

- Un conjunto de valores aleatorios como nÃºmeros reales o cadenas de texto.
- **Cada clave debe ser Ãºnica** dentro del diccionario.

### Â¿QuÃ© operaciones bÃ¡sicas define esta estructura de datos?

- $void Add(K key, V value)$ â†’ Agregar un par clave-valor.
- $V Get(K key)$ â†’ Obtener el valor asociado a una clave.
- $boolean Remove(K key)$ â†’ Eliminar un par clave-valor.

### Â¿QuÃ© mÃ©todos adicionales pueden existir?

- $boolean Contains(K key)$ â†’ Verificar si una clave estÃ¡ en el diccionario.
- $int Count()$ â†’ Obtener la cantidad de elementos almacenados.

---

### Â¿Por quÃ© es importante la implementaciÃ³n de operaciones en un diccionario?

- Muchas aplicaciones requieren un conjunto dinÃ¡mico que soporte Ãºnicamente las operaciones **INSERTAR, BUSCAR y ELIMINAR**.

### Â¿Algunos ejemplos?

- **Compiladores** (traductores de lenguajes de programaciÃ³n):
  - Mantienen una **tabla de sÃ­mbolos**.
  - En ella, las claves son **cadenas de caracteres arbitrarias** que corresponden a identificadores en el lenguaje.

### Â¿CuÃ¡l es una forma eficiente de implementar diccionarios?

- **Utilizando tablas hash**.

[Tabla Hash](https://github.com/marlongv098/Estructuras/blob/master/3_Estructuras_NO_Recursivas/Generics/Diccionario/src/main/java/tablahash/TablaHash.java)

### Â¿Por quÃ©?

- Aunque en el peor caso la bÃºsqueda en una tabla hash puede tardar **Î˜(n)**, en la prÃ¡ctica el rendimiento es muy bueno.
- Bajo suposiciones razonables, el **tiempo promedio de bÃºsqueda** en una tabla hash es **O(1)**.

### Â¿QuÃ© hace una tabla hash?

- Generaliza la nociÃ³n de un **array ordinario**.
- **Acceder directamente** a una posiciÃ³n en un array se hace en **O(1)**.
- Cuando se pueden asignar posiciones a todas las claves posibles, **los arrays son eficientes**.
- Si el nÃºmero de claves almacenadas es pequeÃ±o en comparaciÃ³n con el nÃºmero total de claves posibles, las **tablas hash son una alternativa efectiva**.

# Direccionamiento Directo

### Â¿QuÃ© es el direccionamiento directo?

- Es una tÃ©cnica sencilla que funciona bien cuando el universo $U$ de claves es relativamente pequeÃ±o.
- Supongamos que una aplicaciÃ³n necesita un conjunto dinÃ¡mico en el que cada elemento tiene una clave tomada del universo $U = {0,1,...,m-1}$, donde $m$ no es muy grande y no hay dos elementos con la misma clave.
	- Para representar el conjunto dinÃ¡mico, se usa un **array** o **tabla de direccionamiento directo**, denotado como $T[0..m-1]$.
	- Cada posiciÃ³n o **slot** en el array corresponde a una clave en el universo $U$.
	- El **slot $k$** apunta a un elemento del conjunto con clave $k$.
	- Si el conjunto no contiene un elemento con clave $k$, entonces $T[k] = NIL$.

### Â¿CÃ³mo serÃ­a la implementaciÃ³n de operaciones en un diccionario usando direccionamiento directo?

```java
// BÃºsqueda en direccionamiento directo
T[k] 

// InserciÃ³n en direccionamiento directo
T[x.key] = x 

// EliminaciÃ³n en direccionamiento directo
T[x.key] = NIL 
```

Cada una de estas operaciones tiene un tiempo de ejecuciÃ³n de $O(1)$.

### Ejemplo

Dado el universo $U={0,1,...,9}$ y el conjunto de claves $K={2,3,5,8}$:

[Directo](Images/hash.pdf)

### Â¿CuÃ¡l es la desventaja del direccionamiento directo?

* Si el universo $U$ es muy grande, almacenar una tabla $T$ de tamaÃ±o $|U|$ puede ser imprÃ¡ctico o incluso imposible debido a las limitaciones de memoria de un ordenador tÃ­pico.
* Si $|K|<<|U|$ la mayor parte del espacio reservado para $T$ serÃ­a desperdiciado.

### Â¿QuÃ© hacer si $|K|<<|U|$?

* Usar una tabla hash, ya que requiere mucho menos almacenamiento que una tabla de direccionamiento directo.
* Se puede reducir el requisito de almacenamiento a $Î˜(|K|)$.
* Se mantiene la ventaja de que la bÃºsqueda de un elemento en la tabla hash sigue requiriendo solo $O(1)$ en el caso promedio. Sin embargo, en el peor caso puede tomar mÃ¡s tiempo.

### Â¿QuÃ© es el hashing?

* Mientras que en el direccionamiento directo un elemento con clave $k$ se almacena en la posiciÃ³n $k$, con hashing se almacena en la posiciÃ³n $h(k)$. Se utiliza una funciÃ³n hash $h$ para calcular la posiciÃ³n a partir de la clave $k$.
* La funciÃ³n $h$ mapea el universo $U$ de claves en los slots de una tabla hash $T[0..mâˆ’1]$.

### RepresentaciÃ³n matemÃ¡tica

$$
h:Uâ†’{0,1,...,mâˆ’1}
$$

* Donde $m<<|U|$ y cada elemento tiene una clave distinta $h(k)$ es el valor hash de la clave $k$.
* La funciÃ³n hash reduce el rango de Ã­ndices del array y, por lo tanto, el tamaÃ±o del array.
* En lugar de tener un tamaÃ±o de $|U|$, la tabla puede tener un tamaÃ±o de $m$.

[HashMap](Images/hash1.pdf)


### Â¿CuÃ¡l es el problema con esta soluciÃ³n?

- **Dos claves pueden generar el mismo valor hash**, es decir, pueden ser asignadas al mismo espacio en la tabla.
- A esta situaciÃ³n se le llama **colisiÃ³n**.

### Â¿CÃ³mo resolver el problema de las colisiones?

- La soluciÃ³n ideal serÃ­a evitarlas por completo:
	- Elegir una funciÃ³n de hash $h$ adecuada.
	- Hacer que $h$ parezca aleatoria para minimizar las colisiones.
	- Sin embargo, dado que $|U| > m$, al menos dos claves deben compartir el mismo valor hash, por lo que **es imposible evitarlas por completo**.

---

### Â¿CuÃ¡l es otra manera de resolver este problema?

- Mediante tÃ©cnicas de **resoluciÃ³n de colisiones**, como **encadenamiento**.

#### Â¿QuÃ© es el encadenamiento?

- Es un mecanismo donde todos los elementos que generan el mismo hash se agrupan en una **lista enlazada**.
- El **espacio $j$ de la tabla contiene un puntero** a la cabeza de la lista de elementos que tienen el mismo hash.
- Si no hay elementos en ese espacio, **contiene NIL**.

[Encadenamiento](Images/hash2.pdf)

---

### ImplementaciÃ³n de operaciones en diccionario usando hash y encadenamiento

```java
// InserciÃ³n en hash con encadenamiento
CHAINED-HASH-INSERT(T, x)
  insertar x al inicio de la lista T[h(x.key)]

// BÃºsqueda en hash con encadenamiento
CHAINED-HASH-SEARCH(T, k)
  buscar un elemento con clave k en la lista T[h(k)]

// EliminaciÃ³n en hash con encadenamiento
CHAINED-HASH-DELETE(T, x)
  eliminar x de la lista T[h(x.key)]
```

### Â¿CuÃ¡les son los tiempos de ejecuciÃ³n de estas operaciones?
* InserciÃ³n: $O(1)$ en el peor caso.
* BÃºsqueda: depende de la longitud de la lista, en el peor caso puede ser $O(n)$.
* EliminaciÃ³n: $O(1)$ si las listas estÃ¡n doblemente enlazadas.

Nota: En la eliminaciÃ³n, la funciÃ³n CHAINED-HASH-DELETE recibe el elemento $x$ en lugar de su clave $k$, para evitar una bÃºsqueda adicional.

### Â¿CuÃ¡nto tiempo toma buscar un elemento en una tabla hash con encadenamiento?

* Sea una tabla hash $T$ con $m$ espacios y $n$ elementos. Se define el factor de carga $Î±$ como: $\alpha$ de $T$ como $\frac{n}{m}$
* $\alpha$ representa el nÃºmero promedio de elementos en cada lista.
* En el peor caso, todas las claves colisionan en el mismo espacio, generando una lista de longitud $n$. En este caso, el tiempo de bÃºsqueda serÃ­a $Î˜(n)$, mÃ¡s el tiempo para calcular la funciÃ³n hash.
* ConclusiÃ³n: No usamos tablas hash por su rendimiento en el peor caso, sino por su rendimiento en promedio.

### Rendimiento promedio

* El rendimiento promedio del hashing con encadenamiento depende de quÃ© tan bien la funciÃ³n hash $h$ distribuya uniformemente los elementos.
* Se asume hashing uniforme simple, donde cada elemento es igualmente probable de ser asignado a cualquier espacio en la tabla.

### Casos de bÃºsqueda:

* BÃºsqueda sin Ã©xito: no hay un elemento con clave $k$.
* BÃºsqueda exitosa: encontramos un elemento con clave $k$.


### Teoremas:

* BÃºsqueda sin Ã©xito: en promedio, toma tiempo $Î˜(1+\alpha)$.
* BÃºsqueda exitosa: en promedio, toma tiempo $Î˜(1+\alpha)$.

**Nota:** ambos resultados bajo el supuesto de estar haciendo hashing uniforme.

### Â¿QuÃ© significa este anÃ¡lisis?

* Si el nÃºmero de espacios en la tabla es proporcional al nÃºmero de elementos, es decir, $n=O(m)$ 

$$
 \alpha=O(m)/m=O(1)
$$

* La bÃºsqueda toma tiempo constante en promedio.
* Todas las operaciones del diccionario pueden realizarse en $O(1)$ en promedio.



